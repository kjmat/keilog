スマートメーター計測ロガー
====================

スマートメーターのBルート経由で瞬時電力および積算電力量を取得し、ファイルに記録します。

特徴:
--------------------
- Raspberry Pi + Python3 で動作
  - Raspbian Lite での運用
  - SDカード 4G以上（データ量に応じて）
  - ネットワーク接続（時刻同期のため）
  - python3, python3-serial, python3-requests
- スマートメーターBルートデータ取得機能
  - WiSun モジュール RL7023 Stick-D/DSS（デュアルスタック）に対応
  - （シングルスタックの RL7023 Stick-D/IPS を使うには修正が必要）
  - 取得するプロパティ値と取得間隔を定義できる
  - 状態遷移による振る舞いの管理
- シリアルポートからのデータ取得機能
  - USBに接続した Arduino などの周辺機器から入力されたデータも記録可能
- リモートの Http サーバーにデータを POST する機能
- マルチスレッド（シンプルなフレームワーク）
  - 不慮のエラーによる停止からの回復、長期連続運用が可能
  - 他のセンサー対応など機能の追加が容易

設定例:
--------------------
（Bルートのみ記録する構成）
```python
# keiconf.py

import queue
from keilib.recorder import FileRecorder
from keilib.broute   import BrouteReader

# オブジェクト（スレッド）間で通信を行うための Queue
record_que = queue.Queue(50)

# 動作させるオブジェクトの構成
worker_def = [
    {
        'class': FileRecorder,                  # FileRecorderオブジェクトを作成
        'args': {                               # 引数
            'fname_base': 'mydatafile',         # 記録ファイルの名前に使われる文字列
            'record_que': record_que            # 記録するデータをやり取りする Queue
        }
    },
    {
        'class': BrouteReader,                  # BrouteReaderオブジェクトを作成
        'args': {                               # 引数
            'port': '/dev/serial/by-id/usb-FTDI_FT230X_Basic_UART_xxxxxxxx-if00-port0',
                                                # WiSUNドングルのシリアルポート
            'baudrate': 115200,                 # WiSUNドングルのボーレート
            'broute_id': 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',
                                                # BルートＩＤ（電力会社に申請）
            'broute_pwd': 'xxxxxxxxxxxx',       # Bルートパスワード（電力会社に申請）
            'requests':[                        # 取得するプロパティ値の定義
                { 'epc':['D3','D7','E1'], 'cycle': 3600 },
                                                #   積算電力量用 係数(D3),有効桁数(D7),単位(E1),3600秒ごと
                { 'epc':['E7'], 'cycle': 10 },  #   瞬時電力(E7),10秒ごと
                { 'epc':['E0'], 'cycle': 300 }, #   積算電力量(E0),300秒ごと
            ],
            'record_que': record_que            # 記録するデータをやり取りする Queue
        }
    },
]
```
上記の設定例では、`worker_def` リストに `FileRecorder` と `BrouteReader`
の2つのクラスがコンストラクタへの引数の構成とともに定義されています。
`key.py` はこの設定ファイル `keiconf.py` を読み込み、そこに定義されているクラスのインスタンスを作成し、管理します。
作成されたオブジェクトはそれぞれ別のスレッドで動作を開始しますが、
スレッド間でデータを受け渡すために `queue.Queue` オブジェクトを利用しています。
上記の `record_que` は2つのオブジェクト間でファイルに保存するデータを受け渡すために共有されています。
`BrouteReader` はスマートメーターから情報を得るとフォーマットを整えて `record_que` に投入(put)します。
一方 `FileRecorder` は `recoed_que` に流れてきたデータを取得(get)してファイルに保存します。
Queue オブジェクトはスレッドセーフであるため、排他制御を意識せずに使用できます。

こうした `Queue` を介した連携の中に `SerialReader` など、
また別のスレッドで動作するオブジェクトを加えてやれば、
シリアルポートから入力された Arduino 等のセンサーデータも同様に記録することができます。
また、`HttpPostUploader` を追加すれば、遠隔地のウェブサーバーにデータを送信することもできます。
さらに、様々な機能を追加することも容易で、シンプルですが柔軟に機能を追加できるフレームワークです。

起動方法:
--------------------
Raspbian Lite にあらかじめ pyserial をインストールしておきます。
```sh
$ sudo apt install python3-serial
```
適当な作業ディレクトリを作成し、以下のようにファイルを配置します。

```text
workdir/
    |-- keilib/
    |   |-- __init__.py
    |   |-- broute.py
    |   +-- ....
    |
    |-- keiconf.py
    +-- kei.py
```
`keiconf.py` には構成を定義しておきます。

プログラムの実行は以下のように行います。
```sh
$ python3 kei.py
```
実行すると `workdir/` ディレクトリ内に、計測データを保存するファイルが2つと、
プログラムの実行時の情報を出力するログファイル`kei.log`が作成されます。
ログについては、

```sh
$ DEBUG=0 python3 kei.py
```
のように起動すると、ログレベル = DEBUG となりログの出力先が標準出力になります。
ログレベルは USR1 シグナルを受け取ると INFO <-> DEBUG で反転します。

プログラムの終了については、HUP, INT, TERM シグナルによって各オブジェクトにストップイベントを送っています。
ストップイベントを受けとったオブジェクトのスレッドはリソースを開放してから終了します。

出力ファイルの形式:
--------------------
2つのファイルが作られます。

```
1. [YYYYMMDD]-[mydatafile].txt
2. sum[YYYYMMDD]-[mydatafile].txt
```
1.は1行につき1件のデータが記録されており、行のフォーマットは以下の形をとります。
```text
[YYYY/MM/DD hh:mm:ss],[UnitID],[SensorID],[Value],[DataID]<改行>
```
なお BrouteReader の場合、出力するデータは以下の通りです。
```
[UnitID]    = BR（固定）
[SensorID]  = スマートメーターのプロパティコード(EPC): E7, E0 等
[Value]     = 測定値（数値）
[DataID]    = x（固定）
```
2.は1行に各センサーの10分ごとの平均値が記録されます。
```
[YYYY/MM/DD hh:m0],[UnitID],[SensorID],[AverageValue]<改行>
```
通信頻度について:
--------------------
今回の設定例では10秒に一度瞬時電力を要求していますが、これが電波の有効利用の観点からどうなのか正直良くわかりません。
以下の資料では1分に一度通信する例がでています（通信頻度のページ）が、
これが6倍あるいは10倍になったとしても1時間に360秒以内という条件は余裕をもってクリアしているといえます。

[HEMS-スマートメーターBルート(低圧電力メーター)運用ガイドライン［第4.0版］](https://www.meti.go.jp/committee/kenkyukai/shoujo/smart_house/pdf/009_s03_00.pdf)

通信はベストエフォートであるため、将来HEMS機器や同周波数帯域を使ったIoT機器が普及してくるとなんらかの不具合の原因になるかもしれません。
現状ではそれほど気にする必要はないと感じます。

一方で必要性の観点からいえば、
時計を見るようにリアルタイムに瞬時電力（E7）を見ることには大きな価値があると思います。
それによって不要な照明を消すなどの行動につながるからです。
また将来ホームオートメーションが普及し、HEMSコントローラが瞬時電力を監視して自動的に電気機器を制御するといったケースも同様に価値があります。

しかし人が見ていない時に瞬時電力をデータとして取り続ける必要性がどれほどあるのか疑問です。
たとえば瞬間的に大きな電力を消費している機器や間欠的動作している機器について調べたい場合などが考えられますが、
これは10秒では逆に短いかもしれません。
そもそも得られるデータは家全体の使用電力であるため分析用としてはあまり良いデータではありません。
とはいえ家全体のピーク電力を知ることは契約アンペア見直しの際の情報としての意味や、
同時使用しないほうが良い機器を見出すための調査として意味がありますが、
継続的に調べ続けるなら利用者にどうフィードバックするかが課題です。

人がリアルタイムに見ていないときは、数分ごとに積算電力量（E0）を要求するか、30分ごとに勝手に送られてくる積算電力量（EA）を得るだけで良いのかもしれません。これによって一日の電力利用の状況がわかります。
